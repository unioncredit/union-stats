{"ast":null,"code":"import { isAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport parseRes from \"util/parseRes\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nconst getVouch = (marketRegistryContract, provider) => async (_, account, tokenAddress) => {\n  const ethereumRpc = new JsonRpcProvider(`https://mainnet.infura.io/v3/${process.env.NEXT_PUBLIC_INFURA_KEY}`);\n  const res = await marketRegistryContract.tokens(tokenAddress);\n  const uTokenAddress = res.uToken;\n  const userManagerAddress = res.userManager;\n  const userManagerContract = new Contract(userManagerAddress, USER_MANAGER_ABI, provider);\n  const uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n  const addresses = await userManagerContract.getStakerAddresses(account);\n  const list = await Promise.all(addresses.map(async address => {\n    const {\n      vouchingAmount,\n      lockedStake,\n      trustAmount\n    } = await userManagerContract.getStakerAsset(account, address);\n    const totalUsed = Number(formatUnits(await userManagerContract.getTotalLockedStake(address), 18));\n    const stakingAmount = Number(formatUnits(await userManagerContract.getStakerBalance(address), 18));\n    const isMember = await userManagerContract.checkIsMember(address);\n    const isOverdue = await uTokenContract.checkIsOverdue(address);\n    const vouched = parseRes(vouchingAmount);\n    const used = parseRes(lockedStake);\n    const trust = parseRes(trustAmount);\n    const freeStakingAmount = stakingAmount >= totalUsed ? stakingAmount - totalUsed : 0;\n    const available = Number(vouched) - Number(used) > freeStakingAmount ? freeStakingAmount.toFixed(2) : Number(vouched - used).toFixed(2);\n    const utilized = used / vouched;\n    const ens = await ethereumRpc.lookupAddress(address);\n    return {\n      address,\n      available,\n      isOverdue,\n      trust,\n      used,\n      utilized,\n      vouched,\n      ens,\n      isMember\n    };\n  }));\n  return list;\n};\n\nexport default function useVouchData(address) {\n  const readProvider = useReadProvider();\n  const {\n    account: connectedAccount\n  } = useWeb3React();\n  const account = address || connectedAccount;\n  const curToken = useCurrentToken();\n  const marketRegistryContract = useMarketRegistryContract(readProvider);\n  const shouldFetch = !!marketRegistryContract && typeof account === \"string\" && isAddress(curToken) && Number(curToken) !== 0 && !!readProvider;\n  return useSWR(shouldFetch ? [\"Vouch\", account, curToken] : null, getVouch(marketRegistryContract, readProvider));\n}","map":{"version":3,"sources":["/Users/mathewstokes/Desktop/stats-app/hooks/data/useVouchData.js"],"names":["isAddress","Contract","formatUnits","useWeb3React","U_TOKEN_ABI","useSWR","parseRes","useCurrentToken","useMarketRegistryContract","USER_MANAGER_ABI","JsonRpcProvider","useReadProvider","getVouch","marketRegistryContract","provider","_","account","tokenAddress","ethereumRpc","process","env","NEXT_PUBLIC_INFURA_KEY","res","tokens","uTokenAddress","uToken","userManagerAddress","userManager","userManagerContract","uTokenContract","addresses","getStakerAddresses","list","Promise","all","map","address","vouchingAmount","lockedStake","trustAmount","getStakerAsset","totalUsed","Number","getTotalLockedStake","stakingAmount","getStakerBalance","isMember","checkIsMember","isOverdue","checkIsOverdue","vouched","used","trust","freeStakingAmount","available","toFixed","utilized","ens","lookupAddress","useVouchData","readProvider","connectedAccount","curToken","shouldFetch"],"mappings":"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","sourcesContent":["import { isAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport parseRes from \"util/parseRes\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nconst getVouch =\n  (marketRegistryContract, provider) => async (_, account, tokenAddress) => {\n    const ethereumRpc = new JsonRpcProvider(\n      `https://mainnet.infura.io/v3/${process.env.NEXT_PUBLIC_INFURA_KEY}`\n    );\n    const res = await marketRegistryContract.tokens(tokenAddress);\n    const uTokenAddress = res.uToken;\n    const userManagerAddress = res.userManager;\n\n    const userManagerContract = new Contract(\n      userManagerAddress,\n      USER_MANAGER_ABI,\n      provider\n    );\n\n    const uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n\n    const addresses = await userManagerContract.getStakerAddresses(account);\n\n    const list = await Promise.all(\n      addresses.map(async (address) => {\n        const { vouchingAmount, lockedStake, trustAmount } =\n          await userManagerContract.getStakerAsset(account, address);\n\n        const totalUsed = Number(\n          formatUnits(\n            await userManagerContract.getTotalLockedStake(address),\n            18\n          )\n        );\n\n        const stakingAmount = Number(\n          formatUnits(await userManagerContract.getStakerBalance(address), 18)\n        );\n\n        const isMember = await userManagerContract.checkIsMember(address);\n\n        const isOverdue = await uTokenContract.checkIsOverdue(address);\n\n        const vouched = parseRes(vouchingAmount);\n\n        const used = parseRes(lockedStake);\n\n        const trust = parseRes(trustAmount);\n\n        const freeStakingAmount =\n          stakingAmount >= totalUsed ? stakingAmount - totalUsed : 0;\n\n        const available =\n          Number(vouched) - Number(used) > freeStakingAmount\n            ? freeStakingAmount.toFixed(2)\n            : Number(vouched - used).toFixed(2);\n\n        const utilized = used / vouched;\n\n        const ens = await ethereumRpc.lookupAddress(address);\n\n        return {\n          address,\n          available,\n          isOverdue,\n          trust,\n          used,\n          utilized,\n          vouched,\n          ens,\n          isMember,\n        };\n      })\n    );\n\n    return list;\n  };\n\nexport default function useVouchData(address) {\n  const readProvider = useReadProvider();\n  const { account: connectedAccount } = useWeb3React();\n  const account = address || connectedAccount;\n\n  const curToken = useCurrentToken();\n\n  const marketRegistryContract = useMarketRegistryContract(readProvider);\n\n  const shouldFetch =\n    !!marketRegistryContract &&\n    typeof account === \"string\" &&\n    isAddress(curToken) &&\n    Number(curToken) !== 0 &&\n    !!readProvider;\n\n  return useSWR(\n    shouldFetch ? [\"Vouch\", account, curToken] : null,\n    getVouch(marketRegistryContract, readProvider)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}