{"ast":null,"code":"import { isAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nconst getTrust = (marketRegistryContract, provider) => async (_, account, tokenAddress, count) => {\n  const ethereumRpc = new JsonRpcProvider(`https://mainnet.infura.io/v3/${process.env.NEXT_PUBLIC_INFURA_KEY}`);\n  const res = await marketRegistryContract.tokens(tokenAddress);\n  const uTokenAddress = res.uToken;\n  const userManagerAddress = res.userManager;\n  const userManagerContract = new Contract(userManagerAddress, USER_MANAGER_ABI, provider);\n  const uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n  const addresses = await userManagerContract.getBorrowerAddresses(account);\n  const size = count !== null && count !== void 0 ? count : addresses.length;\n  const data = await Promise.all(addresses.slice(0, size).map(async address => {\n    const res = await userManagerContract.getBorrowerAsset(account, address);\n    const vouched = Number(formatUnits(res.vouchingAmount, 18));\n    const used = Number(formatUnits(res.lockedStake, 18));\n    const trust = Number(formatUnits(res.trustAmount, 18));\n    const percentage = vouched > 0 ? used / vouched : 0;\n    const isOverdue = await uTokenContract.checkIsOverdue(address);\n    const health = isOverdue ? 0 : (vouched - used) / vouched * 100;\n    const ens = await ethereumRpc.lookupAddress(address);\n    const isMember = await userManagerContract.checkIsMember(address);\n    return {\n      address,\n      health,\n      isOverdue,\n      percentage,\n      trust,\n      used,\n      utilized: percentage,\n      vouched,\n      ens,\n      isMember\n    };\n  }));\n  return data;\n};\n\nexport default function useTrustData(address) {\n  const readProvider = useReadProvider();\n  const {\n    account: connectedAccount\n  } = useWeb3React();\n  const account = address || connectedAccount;\n  const curToken = useCurrentToken();\n  const marketRegistryContract = useMarketRegistryContract(readProvider);\n  const shouldFetch = !!marketRegistryContract && typeof account === \"string\" && isAddress(curToken) && !!readProvider;\n  return useSWR(shouldFetch ? [\"Trust\", account, curToken] : null, getTrust(marketRegistryContract, readProvider));\n}","map":{"version":3,"sources":["/Users/mathewstokes/Desktop/stats-app/hooks/data/useTrustData.ts"],"names":["isAddress","Contract","JsonRpcProvider","formatUnits","useWeb3React","U_TOKEN_ABI","useSWR","useMarketRegistryContract","useCurrentToken","USER_MANAGER_ABI","useReadProvider","getTrust","marketRegistryContract","provider","_","account","tokenAddress","count","ethereumRpc","process","env","NEXT_PUBLIC_INFURA_KEY","res","tokens","uTokenAddress","uToken","userManagerAddress","userManager","userManagerContract","uTokenContract","addresses","getBorrowerAddresses","size","length","data","Promise","all","slice","map","address","getBorrowerAsset","vouched","Number","vouchingAmount","used","lockedStake","trust","trustAmount","percentage","isOverdue","checkIsOverdue","health","ens","lookupAddress","isMember","checkIsMember","utilized","useTrustData","readProvider","connectedAccount","curToken","shouldFetch"],"mappings":"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","sourcesContent":["import { isAddress } from \"@ethersproject/address\";\nimport type { BigNumber } from \"@ethersproject/bignumber\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nconst getTrust =\n  (marketRegistryContract: Contract, provider: any) =>\n  async (_: any, account: string, tokenAddress: string, count: number) => {\n    const ethereumRpc = new JsonRpcProvider(\n      `https://mainnet.infura.io/v3/${process.env.NEXT_PUBLIC_INFURA_KEY}`\n    );\n    const res = await marketRegistryContract.tokens(tokenAddress);\n    const uTokenAddress = res.uToken;\n    const userManagerAddress = res.userManager;\n\n    const userManagerContract = new Contract(\n      userManagerAddress,\n      USER_MANAGER_ABI,\n      provider\n    );\n\n    const uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n\n    const addresses: string[] = await userManagerContract.getBorrowerAddresses(\n      account\n    );\n\n    const size = count ?? addresses.length;\n\n    const data = await Promise.all(\n      addresses.slice(0, size).map(async (address) => {\n        const res: {\n          vouchingAmount: BigNumber;\n          lockedStake: BigNumber;\n          trustAmount: BigNumber;\n        } = await userManagerContract.getBorrowerAsset(account, address);\n\n        const vouched = Number(formatUnits(res.vouchingAmount, 18));\n\n        const used = Number(formatUnits(res.lockedStake, 18));\n\n        const trust = Number(formatUnits(res.trustAmount, 18));\n\n        const percentage = vouched > 0 ? used / vouched : 0;\n\n        const isOverdue: boolean = await uTokenContract.checkIsOverdue(address);\n\n        const health = isOverdue ? 0 : ((vouched - used) / vouched) * 100;\n\n        const ens = await ethereumRpc.lookupAddress(address);\n\n        const isMember = await userManagerContract.checkIsMember(address);\n\n        return {\n          address,\n          health,\n          isOverdue,\n          percentage,\n          trust,\n          used,\n          utilized: percentage,\n          vouched,\n          ens,\n          isMember,\n        };\n      })\n    );\n\n    return data;\n  };\n\nexport default function useTrustData(address: string) {\n  const readProvider = useReadProvider();\n  const { account: connectedAccount } = useWeb3React();\n  const account = address || connectedAccount;\n\n  const curToken = useCurrentToken();\n\n  const marketRegistryContract = useMarketRegistryContract(readProvider);\n\n  const shouldFetch =\n    !!marketRegistryContract &&\n    typeof account === \"string\" &&\n    isAddress(curToken) &&\n    !!readProvider;\n\n  return useSWR(\n    shouldFetch ? [\"Trust\", account, curToken] : null,\n    getTrust(marketRegistryContract, readProvider)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}