{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mathewstokes/Desktop/stats-app/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/mathewstokes/Desktop/stats-app/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { isAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nvar getTrust = function getTrust(marketRegistryContract, provider) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_, account, tokenAddress, count) {\n      var ethereumRpc, res, uTokenAddress, userManagerAddress, userManagerContract, uTokenContract, addresses, size, data;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              ethereumRpc = new JsonRpcProvider(\"https://mainnet.infura.io/v3/\".concat(process.env.NEXT_PUBLIC_INFURA_KEY));\n              _context2.next = 3;\n              return marketRegistryContract.tokens(tokenAddress);\n\n            case 3:\n              res = _context2.sent;\n              uTokenAddress = res.uToken;\n              userManagerAddress = res.userManager;\n              userManagerContract = new Contract(userManagerAddress, USER_MANAGER_ABI, provider);\n              uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n              _context2.next = 10;\n              return userManagerContract.getBorrowerAddresses(account);\n\n            case 10:\n              addresses = _context2.sent;\n              size = count !== null && count !== void 0 ? count : addresses.length;\n              _context2.next = 14;\n              return Promise.all(addresses.slice(0, size).map( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n                  var res, vouched, used, trust, percentage, isOverdue, health, ens, isMember;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return userManagerContract.getBorrowerAsset(account, address);\n\n                        case 2:\n                          res = _context.sent;\n                          vouched = Number(formatUnits(res.vouchingAmount, 18));\n                          used = Number(formatUnits(res.lockedStake, 18));\n                          trust = Number(formatUnits(res.trustAmount, 18));\n                          percentage = vouched > 0 ? used / vouched : 0;\n                          _context.next = 9;\n                          return uTokenContract.checkIsOverdue(address);\n\n                        case 9:\n                          isOverdue = _context.sent;\n                          health = isOverdue ? 0 : (vouched - used) / vouched * 100;\n                          _context.next = 13;\n                          return ethereumRpc.lookupAddress(address);\n\n                        case 13:\n                          ens = _context.sent;\n                          _context.next = 16;\n                          return userManagerContract.checkIsMember(address);\n\n                        case 16:\n                          isMember = _context.sent;\n                          return _context.abrupt(\"return\", {\n                            address: address,\n                            health: health,\n                            isOverdue: isOverdue,\n                            percentage: percentage,\n                            trust: trust,\n                            used: used,\n                            utilized: percentage,\n                            vouched: vouched,\n                            ens: ens,\n                            isMember: isMember\n                          });\n\n                        case 18:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x5) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()));\n\n            case 14:\n              data = _context2.sent;\n              return _context2.abrupt(\"return\", data);\n\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nexport default function useTrustData(address) {\n  _s();\n\n  var readProvider = useReadProvider();\n\n  var _useWeb3React = useWeb3React(),\n      connectedAccount = _useWeb3React.account;\n\n  var account = address || connectedAccount;\n  var curToken = useCurrentToken();\n  var marketRegistryContract = useMarketRegistryContract(readProvider);\n  var shouldFetch = !!marketRegistryContract && typeof account === \"string\" && isAddress(curToken) && !!readProvider;\n  return useSWR(shouldFetch ? [\"Trust\", account, curToken] : null, getTrust(marketRegistryContract, readProvider));\n}\n\n_s(useTrustData, \"jalRyZ+AwTFfdtmHmxdIoLzkB8M=\", false, function () {\n  return [useReadProvider, useWeb3React, useCurrentToken, useMarketRegistryContract, useSWR];\n});","map":{"version":3,"sources":["/Users/mathewstokes/Desktop/stats-app/hooks/data/useTrustData.ts"],"names":["isAddress","Contract","JsonRpcProvider","formatUnits","useWeb3React","U_TOKEN_ABI","useSWR","useMarketRegistryContract","useCurrentToken","USER_MANAGER_ABI","useReadProvider","getTrust","marketRegistryContract","provider","_","account","tokenAddress","count","ethereumRpc","process","env","NEXT_PUBLIC_INFURA_KEY","tokens","res","uTokenAddress","uToken","userManagerAddress","userManager","userManagerContract","uTokenContract","getBorrowerAddresses","addresses","size","length","Promise","all","slice","map","address","getBorrowerAsset","vouched","Number","vouchingAmount","used","lockedStake","trust","trustAmount","percentage","checkIsOverdue","isOverdue","health","lookupAddress","ens","checkIsMember","isMember","utilized","data","useTrustData","readProvider","connectedAccount","curToken","shouldFetch"],"mappings":"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","sourcesContent":["import { isAddress } from \"@ethersproject/address\";\nimport type { BigNumber } from \"@ethersproject/bignumber\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nconst getTrust =\n  (marketRegistryContract: Contract, provider: any) =>\n  async (_: any, account: string, tokenAddress: string, count: number) => {\n    const ethereumRpc = new JsonRpcProvider(\n      `https://mainnet.infura.io/v3/${process.env.NEXT_PUBLIC_INFURA_KEY}`\n    );\n    const res = await marketRegistryContract.tokens(tokenAddress);\n    const uTokenAddress = res.uToken;\n    const userManagerAddress = res.userManager;\n\n    const userManagerContract = new Contract(\n      userManagerAddress,\n      USER_MANAGER_ABI,\n      provider\n    );\n\n    const uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n\n    const addresses: string[] = await userManagerContract.getBorrowerAddresses(\n      account\n    );\n\n    const size = count ?? addresses.length;\n\n    const data = await Promise.all(\n      addresses.slice(0, size).map(async (address) => {\n        const res: {\n          vouchingAmount: BigNumber;\n          lockedStake: BigNumber;\n          trustAmount: BigNumber;\n        } = await userManagerContract.getBorrowerAsset(account, address);\n\n        const vouched = Number(formatUnits(res.vouchingAmount, 18));\n\n        const used = Number(formatUnits(res.lockedStake, 18));\n\n        const trust = Number(formatUnits(res.trustAmount, 18));\n\n        const percentage = vouched > 0 ? used / vouched : 0;\n\n        const isOverdue: boolean = await uTokenContract.checkIsOverdue(address);\n\n        const health = isOverdue ? 0 : ((vouched - used) / vouched) * 100;\n\n        const ens = await ethereumRpc.lookupAddress(address);\n\n        const isMember = await userManagerContract.checkIsMember(address);\n\n        return {\n          address,\n          health,\n          isOverdue,\n          percentage,\n          trust,\n          used,\n          utilized: percentage,\n          vouched,\n          ens,\n          isMember,\n        };\n      })\n    );\n\n    return data;\n  };\n\nexport default function useTrustData(address: string) {\n  const readProvider = useReadProvider();\n  const { account: connectedAccount } = useWeb3React();\n  const account = address || connectedAccount;\n\n  const curToken = useCurrentToken();\n\n  const marketRegistryContract = useMarketRegistryContract(readProvider);\n\n  const shouldFetch =\n    !!marketRegistryContract &&\n    typeof account === \"string\" &&\n    isAddress(curToken) &&\n    !!readProvider;\n\n  return useSWR(\n    shouldFetch ? [\"Trust\", account, curToken] : null,\n    getTrust(marketRegistryContract, readProvider)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}