{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mathewstokes/Desktop/stats-app/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/mathewstokes/Desktop/stats-app/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { isAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport parseRes from \"util/parseRes\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nvar getVouch = function getVouch(marketRegistryContract, provider) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_, account, tokenAddress) {\n      var ethereumRpc, res, uTokenAddress, userManagerAddress, userManagerContract, uTokenContract, addresses, list;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              ethereumRpc = new JsonRpcProvider(\"https://mainnet.infura.io/v3/\".concat(process.env.NEXT_PUBLIC_INFURA_KEY));\n              _context2.next = 3;\n              return marketRegistryContract.tokens(tokenAddress);\n\n            case 3:\n              res = _context2.sent;\n              uTokenAddress = res.uToken;\n              userManagerAddress = res.userManager;\n              userManagerContract = new Contract(userManagerAddress, USER_MANAGER_ABI, provider);\n              uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n              _context2.next = 10;\n              return userManagerContract.getStakerAddresses(account);\n\n            case 10:\n              addresses = _context2.sent;\n              _context2.next = 13;\n              return Promise.all(addresses.map( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n                  var _yield$userManagerCon, vouchingAmount, lockedStake, trustAmount, totalUsed, stakingAmount, isMember, isOverdue, vouched, used, trust, freeStakingAmount, available, utilized, ens;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return userManagerContract.getStakerAsset(account, address);\n\n                        case 2:\n                          _yield$userManagerCon = _context.sent;\n                          vouchingAmount = _yield$userManagerCon.vouchingAmount;\n                          lockedStake = _yield$userManagerCon.lockedStake;\n                          trustAmount = _yield$userManagerCon.trustAmount;\n                          _context.t0 = Number;\n                          _context.t1 = formatUnits;\n                          _context.next = 10;\n                          return userManagerContract.getTotalLockedStake(address);\n\n                        case 10:\n                          _context.t2 = _context.sent;\n                          _context.t3 = (0, _context.t1)(_context.t2, 18);\n                          totalUsed = (0, _context.t0)(_context.t3);\n                          _context.t4 = Number;\n                          _context.t5 = formatUnits;\n                          _context.next = 17;\n                          return userManagerContract.getStakerBalance(address);\n\n                        case 17:\n                          _context.t6 = _context.sent;\n                          _context.t7 = (0, _context.t5)(_context.t6, 18);\n                          stakingAmount = (0, _context.t4)(_context.t7);\n                          _context.next = 22;\n                          return userManagerContract.checkIsMember(address);\n\n                        case 22:\n                          isMember = _context.sent;\n                          _context.next = 25;\n                          return uTokenContract.checkIsOverdue(address);\n\n                        case 25:\n                          isOverdue = _context.sent;\n                          vouched = parseRes(vouchingAmount);\n                          used = parseRes(lockedStake);\n                          trust = parseRes(trustAmount);\n                          freeStakingAmount = stakingAmount >= totalUsed ? stakingAmount - totalUsed : 0;\n                          available = Number(vouched) - Number(used) > freeStakingAmount ? freeStakingAmount.toFixed(2) : Number(vouched - used).toFixed(2);\n                          utilized = used / vouched;\n                          _context.next = 34;\n                          return ethereumRpc.lookupAddress(address);\n\n                        case 34:\n                          ens = _context.sent;\n                          return _context.abrupt(\"return\", {\n                            address: address,\n                            available: available,\n                            isOverdue: isOverdue,\n                            trust: trust,\n                            used: used,\n                            utilized: utilized,\n                            vouched: vouched,\n                            ens: ens,\n                            isMember: isMember\n                          });\n\n                        case 36:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x4) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()));\n\n            case 13:\n              list = _context2.sent;\n              return _context2.abrupt(\"return\", list);\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nexport default function useVouchData(address) {\n  _s();\n\n  var readProvider = useReadProvider();\n\n  var _useWeb3React = useWeb3React(),\n      connectedAccount = _useWeb3React.account;\n\n  var account = address || connectedAccount;\n  var curToken = useCurrentToken();\n  var marketRegistryContract = useMarketRegistryContract(readProvider);\n  var shouldFetch = !!marketRegistryContract && typeof account === \"string\" && isAddress(curToken) && Number(curToken) !== 0 && !!readProvider;\n  return useSWR(shouldFetch ? [\"Vouch\", account, curToken] : null, getVouch(marketRegistryContract, readProvider));\n}\n\n_s(useVouchData, \"jalRyZ+AwTFfdtmHmxdIoLzkB8M=\", false, function () {\n  return [useReadProvider, useWeb3React, useCurrentToken, useMarketRegistryContract, useSWR];\n});","map":{"version":3,"sources":["/Users/mathewstokes/Desktop/stats-app/hooks/data/useVouchData.js"],"names":["isAddress","Contract","formatUnits","useWeb3React","U_TOKEN_ABI","useSWR","parseRes","useCurrentToken","useMarketRegistryContract","USER_MANAGER_ABI","JsonRpcProvider","useReadProvider","getVouch","marketRegistryContract","provider","_","account","tokenAddress","ethereumRpc","process","env","NEXT_PUBLIC_INFURA_KEY","tokens","res","uTokenAddress","uToken","userManagerAddress","userManager","userManagerContract","uTokenContract","getStakerAddresses","addresses","Promise","all","map","address","getStakerAsset","vouchingAmount","lockedStake","trustAmount","Number","getTotalLockedStake","totalUsed","getStakerBalance","stakingAmount","checkIsMember","isMember","checkIsOverdue","isOverdue","vouched","used","trust","freeStakingAmount","available","toFixed","utilized","lookupAddress","ens","list","useVouchData","readProvider","connectedAccount","curToken","shouldFetch"],"mappings":"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","sourcesContent":["import { isAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport U_TOKEN_ABI from \"constants/abis/uToken.json\";\nimport useSWR from \"swr\";\nimport parseRes from \"util/parseRes\";\nimport useCurrentToken from \"../useCurrentToken\";\nimport useMarketRegistryContract from \"../contracts/useMarketRegistryContract\";\nimport USER_MANAGER_ABI from \"constants/abis/userManager.json\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport useReadProvider from \"hooks/useReadProvider\";\n\nconst getVouch =\n  (marketRegistryContract, provider) => async (_, account, tokenAddress) => {\n    const ethereumRpc = new JsonRpcProvider(\n      `https://mainnet.infura.io/v3/${process.env.NEXT_PUBLIC_INFURA_KEY}`\n    );\n    const res = await marketRegistryContract.tokens(tokenAddress);\n    const uTokenAddress = res.uToken;\n    const userManagerAddress = res.userManager;\n\n    const userManagerContract = new Contract(\n      userManagerAddress,\n      USER_MANAGER_ABI,\n      provider\n    );\n\n    const uTokenContract = new Contract(uTokenAddress, U_TOKEN_ABI, provider);\n\n    const addresses = await userManagerContract.getStakerAddresses(account);\n\n    const list = await Promise.all(\n      addresses.map(async (address) => {\n        const { vouchingAmount, lockedStake, trustAmount } =\n          await userManagerContract.getStakerAsset(account, address);\n\n        const totalUsed = Number(\n          formatUnits(\n            await userManagerContract.getTotalLockedStake(address),\n            18\n          )\n        );\n\n        const stakingAmount = Number(\n          formatUnits(await userManagerContract.getStakerBalance(address), 18)\n        );\n\n        const isMember = await userManagerContract.checkIsMember(address);\n\n        const isOverdue = await uTokenContract.checkIsOverdue(address);\n\n        const vouched = parseRes(vouchingAmount);\n\n        const used = parseRes(lockedStake);\n\n        const trust = parseRes(trustAmount);\n\n        const freeStakingAmount =\n          stakingAmount >= totalUsed ? stakingAmount - totalUsed : 0;\n\n        const available =\n          Number(vouched) - Number(used) > freeStakingAmount\n            ? freeStakingAmount.toFixed(2)\n            : Number(vouched - used).toFixed(2);\n\n        const utilized = used / vouched;\n\n        const ens = await ethereumRpc.lookupAddress(address);\n\n        return {\n          address,\n          available,\n          isOverdue,\n          trust,\n          used,\n          utilized,\n          vouched,\n          ens,\n          isMember,\n        };\n      })\n    );\n\n    return list;\n  };\n\nexport default function useVouchData(address) {\n  const readProvider = useReadProvider();\n  const { account: connectedAccount } = useWeb3React();\n  const account = address || connectedAccount;\n\n  const curToken = useCurrentToken();\n\n  const marketRegistryContract = useMarketRegistryContract(readProvider);\n\n  const shouldFetch =\n    !!marketRegistryContract &&\n    typeof account === \"string\" &&\n    isAddress(curToken) &&\n    Number(curToken) !== 0 &&\n    !!readProvider;\n\n  return useSWR(\n    shouldFetch ? [\"Vouch\", account, curToken] : null,\n    getVouch(marketRegistryContract, readProvider)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}