{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { formatUnits } from \"@ethersproject/units\";\nimport useGovernanceContract from \"hooks/contracts/useGovernanceContract\";\nimport useSWR from \"swr\";\nimport { useDataFromEventLogs } from \"./useDataFromEventLogs\";\nimport useReadProvider from \"hooks/useReadProvider\";\nimport useChainId from \"hooks/useChainId\";\nimport { BLOCK_SPEED } from \"constants/variables\";\nimport getDateFromBlock from \"util/getDateFromBlock\";\nconst ProposalStateStrings = [\"pending\", \"active\", \"canceled\", \"defeated\", \"succeeded\", \"queued\", \"expired\", \"executed\"];\n\nconst getAllProposalData = async (_, chainId, library, govContract, formattedEvents) => {\n  const allProposals = await Promise.all(formattedEvents.map(async event => {\n    return await govContract.proposals(event.pid);\n  }));\n  const allProposalStates = await Promise.all(formattedEvents.map(async event => {\n    return await govContract.state(event.pid);\n  }));\n  const allProposalDetails = await Promise.all(formattedEvents.map(async event => {\n    return await govContract.getActions(event.pid);\n  }));\n  const formattedAllProposals = allProposals.map((proposal, i) => {\n    var _String, _String$replace, _String$replace$split, _String2, _String2$replace, _String2$replace$spli, _String2$replace$spli2;\n\n    if (!proposal || typeof allProposalStates[i] !== \"number\" || !formattedEvents[i]) {\n      return false;\n    }\n\n    return _objectSpread(_objectSpread({}, formattedEvents[i]), {}, {\n      signatures: allProposalDetails[i].signatures,\n      calldatas: allProposalDetails[i].calldatas,\n      targets: allProposalDetails[i].targets,\n      title: ((_String = String(formattedEvents[i].description)) === null || _String === void 0 ? void 0 : (_String$replace = _String.replace(/\\\\{1,2}n/g, \"\\n\")) === null || _String$replace === void 0 ? void 0 : (_String$replace$split = _String$replace.split(\"\\n\")) === null || _String$replace$split === void 0 ? void 0 : _String$replace$split.filter(Boolean)[0]) || \"Untitled\",\n      description: ((_String2 = String(formattedEvents[i].description)) === null || _String2 === void 0 ? void 0 : (_String2$replace = _String2.replace(/\\\\{1,2}n/, \"\\n\")) === null || _String2$replace === void 0 ? void 0 : (_String2$replace$spli = _String2$replace.split(\"\\n\")) === null || _String2$replace$spli === void 0 ? void 0 : (_String2$replace$spli2 = _String2$replace$spli.slice(2)) === null || _String2$replace$spli2 === void 0 ? void 0 : _String2$replace$spli2.join(\"\\n\\n\")) || \"No description\",\n      proposer: proposal.proposer,\n      status: ProposalStateStrings[allProposalStates[i]] || \"Undetermined\",\n      forCount: parseFloat(formatUnits(proposal.forVotes.toString(), 18)),\n      againstCount: parseFloat(formatUnits(proposal.againstVotes.toString(), 18)),\n      startBlock: parseInt(proposal.startBlock.toString()),\n      endBlock: parseInt(proposal.endBlock.toString()),\n      eta: parseInt(proposal.eta.toString()),\n      type: \"onchain\"\n    });\n  }).filter(Boolean);\n  const formattedAllProposalsWithTimestamp = await Promise.all(formattedAllProposals.map(async proposal => {\n    const startTimestamp = await getDateFromBlock(library, proposal.startBlock, BLOCK_SPEED[chainId]);\n    const endTimestamp = await getDateFromBlock(library, proposal.endBlock, BLOCK_SPEED[chainId]);\n    return _objectSpread(_objectSpread({}, proposal), {}, {\n      startTimestamp,\n      endTimestamp\n    });\n  }));\n  return formattedAllProposalsWithTimestamp.sort((a, b) => b.startTimestamp - a.startTimestamp);\n};\n\nexport default function useAllProposalData() {\n  const library = useReadProvider();\n  const chainId = useChainId();\n  const govContract = useGovernanceContract(library);\n  const {\n    data: formattedEvents\n  } = useDataFromEventLogs();\n  const shouldFetch = Boolean(govContract && formattedEvents && library);\n  return useSWR(shouldFetch ? [`AllProposalData-${formattedEvents.length}`, chainId, library, govContract, formattedEvents] : null, getAllProposalData, {\n    shouldRetryOnError: false,\n    refreshWhenHidden: false,\n    refreshWhenOffline: false,\n    revalidateOnFocus: false,\n    revalidateOnReconnect: false\n  });\n}","map":{"version":3,"sources":["/Users/mathewstokes/Desktop/stats-app/hooks/governance/useAllProposalData.js"],"names":["formatUnits","useGovernanceContract","useSWR","useDataFromEventLogs","useReadProvider","useChainId","BLOCK_SPEED","getDateFromBlock","ProposalStateStrings","getAllProposalData","_","chainId","library","govContract","formattedEvents","allProposals","Promise","all","map","event","proposals","pid","allProposalStates","state","allProposalDetails","getActions","formattedAllProposals","proposal","i","signatures","calldatas","targets","title","String","description","replace","split","filter","Boolean","slice","join","proposer","status","forCount","parseFloat","forVotes","toString","againstCount","againstVotes","startBlock","parseInt","endBlock","eta","type","formattedAllProposalsWithTimestamp","startTimestamp","endTimestamp","sort","a","b","useAllProposalData","data","shouldFetch","length","shouldRetryOnError","refreshWhenHidden","refreshWhenOffline","revalidateOnFocus","revalidateOnReconnect"],"mappings":"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","sourcesContent":["import { formatUnits } from \"@ethersproject/units\";\nimport useGovernanceContract from \"hooks/contracts/useGovernanceContract\";\nimport useSWR from \"swr\";\nimport { useDataFromEventLogs } from \"./useDataFromEventLogs\";\nimport useReadProvider from \"hooks/useReadProvider\";\nimport useChainId from \"hooks/useChainId\";\nimport { BLOCK_SPEED } from \"constants/variables\";\nimport getDateFromBlock from \"util/getDateFromBlock\";\n\nconst ProposalStateStrings = [\n  \"pending\",\n  \"active\",\n  \"canceled\",\n  \"defeated\",\n  \"succeeded\",\n  \"queued\",\n  \"expired\",\n  \"executed\",\n];\n\nconst getAllProposalData = async (\n  _,\n  chainId,\n  library,\n  govContract,\n  formattedEvents\n) => {\n  const allProposals = await Promise.all(\n    formattedEvents.map(async (event) => {\n      return await govContract.proposals(event.pid);\n    })\n  );\n\n  const allProposalStates = await Promise.all(\n    formattedEvents.map(async (event) => {\n      return await govContract.state(event.pid);\n    })\n  );\n\n  const allProposalDetails = await Promise.all(\n    formattedEvents.map(async (event) => {\n      return await govContract.getActions(event.pid);\n    })\n  );\n\n  const formattedAllProposals = allProposals\n    .map((proposal, i) => {\n      if (\n        !proposal ||\n        typeof allProposalStates[i] !== \"number\" ||\n        !formattedEvents[i]\n      ) {\n        return false;\n      }\n\n      return {\n        ...formattedEvents[i],\n        signatures: allProposalDetails[i].signatures,\n        calldatas: allProposalDetails[i].calldatas,\n        targets: allProposalDetails[i].targets,\n        title:\n          String(formattedEvents[i].description)\n            ?.replace(/\\\\{1,2}n/g, \"\\n\")\n            ?.split(\"\\n\")\n            ?.filter(Boolean)[0] || \"Untitled\",\n        description:\n          String(formattedEvents[i].description)\n            ?.replace(/\\\\{1,2}n/, \"\\n\")\n            ?.split(\"\\n\")\n            ?.slice(2)\n            ?.join(\"\\n\\n\") || \"No description\",\n        proposer: proposal.proposer,\n        status: ProposalStateStrings[allProposalStates[i]] || \"Undetermined\",\n        forCount: parseFloat(formatUnits(proposal.forVotes.toString(), 18)),\n        againstCount: parseFloat(\n          formatUnits(proposal.againstVotes.toString(), 18)\n        ),\n        startBlock: parseInt(proposal.startBlock.toString()),\n        endBlock: parseInt(proposal.endBlock.toString()),\n        eta: parseInt(proposal.eta.toString()),\n        type: \"onchain\",\n      };\n    })\n    .filter(Boolean);\n\n  const formattedAllProposalsWithTimestamp = await Promise.all(\n    formattedAllProposals.map(async (proposal) => {\n      const startTimestamp = await getDateFromBlock(\n        library,\n        proposal.startBlock,\n        BLOCK_SPEED[chainId]\n      );\n\n      const endTimestamp = await getDateFromBlock(\n        library,\n        proposal.endBlock,\n        BLOCK_SPEED[chainId]\n      );\n\n      return {\n        ...proposal,\n        startTimestamp,\n        endTimestamp,\n      };\n    })\n  );\n\n  return formattedAllProposalsWithTimestamp.sort(\n    (a, b) => b.startTimestamp - a.startTimestamp\n  );\n};\n\nexport default function useAllProposalData() {\n  const library = useReadProvider();\n  const chainId = useChainId();\n\n  const govContract = useGovernanceContract(library);\n\n  const { data: formattedEvents } = useDataFromEventLogs();\n\n  const shouldFetch = Boolean(govContract && formattedEvents && library);\n\n  return useSWR(\n    shouldFetch\n      ? [\n          `AllProposalData-${formattedEvents.length}`,\n          chainId,\n          library,\n          govContract,\n          formattedEvents,\n        ]\n      : null,\n    getAllProposalData,\n    {\n      shouldRetryOnError: false,\n      refreshWhenHidden: false,\n      refreshWhenOffline: false,\n      revalidateOnFocus: false,\n      revalidateOnReconnect: false,\n    }\n  );\n}\n"]},"metadata":{},"sourceType":"module"}